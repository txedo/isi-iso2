\paragraph{Capa de dominio} \label{frontendDominio}

Una de las primeras decisiones tomadas fue la de dividir esta capa en un paquete de conocimiento y en otro de control. En el primero de ellos se encuentran todas las clases del modelo de dominio (además de algunas enumeraciones e interfaces con constantes), que son aquellas clases cuya única responsabilidad es la de mantener información. \\
\indent Por otro lado, en el paquete de control se han colocado todas las clases que se encargan de gestionar las clases de conocimiento y las comunicaciones con la capa de persistencia, presentación y con la unidad de citación (a través de la capa de comunicaciones). Sin embargo, para cumplir con el principio de mínimo acoplamiento y máxima cohesión, estos \textit{gestores} agrupan responsabilidades que están relacionadas con la gestión de una clase del modelo de conocimiento. Por ejemplo, para gestionar la clase de conocimiento \textit{Beneficiario}, se ha creado la clase \textit{GestorBeneficiarios}, cuyas responsabilidades son consultar un beneficiario, crearlo, etc. \\
\indent Se puede observar la división de esta capa y las relaciones con otras capas en el \diagrama{frontend}{paquetes}{División en Capas}.

Además, estos gestores delegan la persistencia de las clases de conocimiento a las diferentes \textit{Fabricaciones Puras} de la capa de persistencia, evitando así que las clases del modelo de dominio estén acopladas con la capa de persistencia, lo que se puede considerar como un patrón \textbf{Indirección}. \\
\indent Todos los gestores, y las relaciones existentes entre ellos, se pueden apreciar en el \diagrama{frontend}{clases}{Gestores}.

En lo que se refiere a los tipos de usuarios que pueden utilizar el sistema, se decidió utilizar las siguientes clases y jerarquía de herencia: existe una clase abstracta llamada \textit{Usuario} de la que heredan las clases \textit{Médico}, \textit{Administrador} y \textit{Citador}. La clase \textit{Usuario} es abstracta ya que no se van a instanciar objetos directamente de esa clase, sino de una de sus subclases, que representan los diferentes usuarios que pueden existir en el sistema, según la especificación de requisitos (ver sección \ref{requisitosIniciales}). Además, la solución propuesta facilita la extensibilidad futura del sistema, ya que el rol de cada usuario se define mediante la enumeración \textit{RolesUsuario}, de tal modo que cada subclase de la clase \textit{Usuario} redefinirá el método abstracto \textit{getRol()}, devolviendo el valor correspondiente a su rol en la enumeración. Por tanto, para añadir un nuevo rol de usuario, basta con añadir una nueva clase que herede de la superclase y un nuevo rol a la enumeración.\\
\indent También, según la especificación de requisitos, la clase \textit{Médico} hereda de \textit{Usuario} porque los médicos deben utilizar la Unidad de Citación para consultar sus propias citas, emitir volantes y consultar beneficiarios (ver Tabla \ref{tb:operacionesInterfaz}), haciendo necesario que estén dados de alta en el sistema y dispongan de su nombre de usuario y contraseña correspondientes. \\
\indent Por otra parte, la clase \textit{Administrador} hereda de la clase \textit{Citador} porque un administrador puede hacer todas las operaciones de un citador más las suyas propias (ver Tabla \ref{tb:operacionesInterfaz}). \\
\indent Esta jerarquía de herencia se puede observar en el \diagrama{frontend}{clases}{Gestor Usuarios}.

Por otra parte, para aumentar la seguridad del sistema, se decidió encriptar la contraseña de los usuarios, utilizando para ello el algoritmo SHA1. 
Algunas de las razones para utilizar una encriptación por código y no delegar esta responsabilidad en el sistema gestor de base de datos, son las siguientes: 
\begin{enumerate}
	\item Si se quiere cambiar la encriptación a una más segura, no haría falta más que cambiar el método que encripta la contraseña.
	\item Puede que otros SGBD que no sean MySQL no tengan encriptación incorporada.
	\item El número de encriptaciones que incorpora un SGBD es limitado.
\end{enumerate}

Siguiendo con el tema de la herencia, se planteó la posibilidad de hacer una clase \textit{Persona} de la que heredan \textit{Usuario} y \textit{Beneficiario}, pero esta alternativa ha sido rechazada debido a que al aplicar el patrón de persistencia \textbf{1 Camino de Herencia, 1 tabla}, el resultado obtenido sería el mismo que el que se ha obtenido. Además, dicha herencia no estaría del todo justificada, ya que únicamente se especializarían las clases definiendo algunos atributos diferentes a los de la superclase, pero no métodos ni comportamientos distintos, como ocurre en el caso de la herencia de usuarios.

Otra decisión de diseño tomada ha sido utilizar el patrón \textbf{Estado} para representar los diferentes tipos de médicos. Dicho patrón facilita la futura extensibilidad del sistema, debido a que un médico puede pertenecer a distintos tipos (por ejemplo, cabecera y especialista) y se podría cambiar su tipo en tiempo de ejecución para ejecutar unas u otras operaciones, dependiendo del tipo de médico. \\
\indent No obstante, en lo que se refiere a este aspecto (cambio de tipo en tiempo de ejecución), el uso de este patrón no está totalmente justificado, pues actualmente no se permite que un médico pueda ser de dos tipos. \\
\indent La implementación de este patrón puede observarse en el \diagrama{frontend}{clases}{Gestor Usuarios}.

Referente también a los médicos, en la especificación de requisitos (ver sección \ref{requisitosIniciales}) se indica que los médicos tienen un calendario laboral, en el cuál se definen los días y las horas que trabajan. En el sistema, ésto se ha representado mediante el concepto \textit{conjunto de periodos de trabajos}, donde un \textit{periodo de trabajo} es una clase que define el día de la semana y el intervalo de horas consecutivas que se trabaja ese día (hora de inicio y hora de fin del intervalo). De este modo, se permite que un médico pueda definir un calendario laboral variable, trabajando, por ejemplo, el Lunes de 9:00 a 14:00 y de 17:00 a 21:00. \\
\indent Hay que resaltar que se crea un nuevo periodo de trabajo cuando las horas no son consecutivas dentro del intervalo seleccionado. Así, en el ejemplo anterior se crearian dos periodos diferentes para el mismo día).

En cuanto a lo que se refiere a la interfaz remota que debe ofrecer el servidor front-end, se ha decidido implementar una clase \textit{ServidorFrontend} que es la que implementa dicha interfaz y, a la vez, es un patrón \textbf{Fachada} y \textbf{Singleton}, de tal modo que esta fachada únicamente recibe las peticiones del cliente y las delega en los distintos gestores que forman parte de la lógica del sistema. \\
\indent Esto se puede apreciar en el \diagrama{frontend}{clases}{Servidor Front-end}.

Otro de los requisitos del sistema consiste en que al realizar determinadas operaciones desde alguno de los clientes conectados al servidor, el resto de clientes deben actualizar sus ventanas, si procede, para reflejar dichos cambios. Para esto, se implementa un patrón \textbf{Observador}, donde el \textit{Gestor de Sesiones} del servidor front-end adquiere el rol de observado (\textit{''subject''}), ya que mantiene la lista de clientes activos (que son los observadores) y notifica los cambios a cada uno de ellos. Los observadores, a su vez, implementan una interfaz \textit{ICliente}, sobre la cuál realiza las llamadas el \textit{Gestor de Sesiones} para notificar los cambios. De este modo, si el cliente cambia su implementación del método que actualiza los cambios en la interfaz gráfica, el servidor sigue siendo independiente, ya que está programado contra la interfaz \textit{ICliente} (ver \diagrama{frontend}{clases}{Gestor Sesiones}).

Continuando con el \textit{Gestor de Sesiones}, otra decisión de diseño que se ha tomado ha sido que si se elimina el usuario que tiene una sesión iniciada en el sistema, se cierra esa sesión y se actualiza al cliente oportuno. También, si un usuario inicia una sesión que ya está activa desde otro terminal, se cierra la sesión activa y se abre la nueva sesión. \\
\indent Para terminar, hay que señalar que si se desconecta el servidor front-end y existen clientes conectados a él, se cierran todas las sesiones activas y se informa a dichos clientes.