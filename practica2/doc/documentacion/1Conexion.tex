\section{Conexión de la aplicación Web con el servidor}

% Comentar algo, en plan de pequeña introducción
% Incluir secciones del diagrama de clases y comentar el proxy 

% Hay que hacer un diagrama parecido al que aparece en el enunciado
% pero donde se vea cómo hemos hecho la conexión con la aplicación web
% (la web usa el servidor RMI del 1er parcial)

\subsection{Cambios realizados en el servidor front-end} \label{cambios}

Ha sido necesario realizar ligeras modificaciones en el sistema desarrollado con anterioridad para poder dar soporte a la funcionalidad que debe tener la aplicación Web y para que dicha aplicación pueda utilizar y comunicarse con el servidor front-end ya desarrollado. 

Estas modificaciones se enumeran a continuación, comentando brevemente el motivo de realizar cada uno de los cambios.

\begin{milista}

	\item La aplicación Web debe permitir iniciar sesión a un beneficiario, por lo que es necesario incluir en el servidor front-end una sesion para ellos. Por tanto, la clase \textit{Sesión} del servidor front-end ha pasado a ser abstracta y ya no tiene asociado un usuario, para poder generalizar las sesiones de los usuarios y los beneficiarios. \\
	De este modo, la clase abstracta \textit{Sesión} tiene tiene dos especializaciones: \textit{SesionUsuario} y \textit{SesionBeneficiario}, cada una de las cuales tiene asociado un objeto del tipo adecuado (usuario o beneficiario).
	Además, se ha incluido el rol de ''Beneficiario'' en la enumeración de roles que ya existía en el sistema, renombrándose por \textit{Roles}, en lugar de \textit{RolesUsuario}.

	\item Para poder identificar unívocamente a los clientes que inician sesión en la alicación Web sin conocer su rol (médico o beneficiario), se ha añadido el método abstracto ''getNombre()'' a la clase \textit{Sesión}, el cual se implementa en la clase \textit{SesionUsuario}, devolviendo el login del usuario, y en la clase \textit{SesionBeneficiario}, devolviendo el NIF del beneficiario.

	\item Debido al cambio en las sesiones, se han tenido que cambiar las operaciones de algunos gestores que accedían al campo ''usuario'' de la \textit{Sesión}, accediendo ahora a dicho campo de la clase \textit{SesionUsurio}. Además, todas las llamadas a los métodos de la clase \textit{ServidorFrontend} que escribían en el log también se han modificado, para utilizar el nuevo método ''getNombre()'' para identificar al cliente que inicie sesión.

	\item En el cliente se han modificado todas las referencias a la enumeración \textit{RolesUsuario} por \textit{Roles}.

	\item El método ''identificar'' del servidor front-end se ha renombrado por ''identificarUsuario'' y se ha creado el método ''identificarBeneficiario'', actualizándose las clases \textit{GestorSesion} y \textit{ServidorFrontend}.

	\item Añadido en la clase \textit{GestorMédicos} el método para consultar un médico a partir de su login, necesario para recuperar el objeto de tipo médico cuando un cliente con este rol inicia sesión en la aplicación Web. Dicho método también se ha añadido en la clase \textit{GestorUsuarios}.
	
	\item Para seguir manteniendo la interfaz \textit{IServidor}, el método para identificar un beneficiario se realiza con el método ''mensajeAuxiliar''. Lo mismo sucede para para consultar un medico por su login.

	\item Las operaciones ''identificarBeneficiario'' y ''consultarPorLogin'' sólo se han añadido al proxy de la aplicación Web, pues los clientes de la aplicación de escritorio no utilizan dichos métodos.

	\item Creado un método en la clase \textit{GestorCitas} para consultar una cita, dado su identificador. Este método se invoca a través del mensaje auxiliar de la interfaz \textit{IServidor}.

	\item Ha sido necesario modificar los permisos de las operaciones que pueden realizar los diferentes roles, para poder permitir realizar dichas operaciones al beneficiario y al médico. A continuación, se citan los permisos que se han añadido al rol de beneficiario y de médico: 
	\begin{itemize}
		\item El médico debe poder consultar los beneficiarios que tiene asignados, para mostrarlos en la página Web ''darVolante.jsp''. 	
		\item La operación ''ConsultarMedico'' la puede realizar ahora también un médico y un beneficiario, porque se necesita consultar el médico receptor para poder emitir un volante. 
		\item Para consultar un medico por su login, se ha creado una operación nueva que se llama ''ConsultarPropioMedico'', que la puede realizar un medico o el administrador del sistema.	
		\item Se ha añadido un permiso para que un beneficiario pueda consultar sus citas.
		\item Añadido un permiso para que un beneficiario pueda anular una cita.
		\item Modificados los permisos para que un beneficiario pueda consultar las horas libres y ocupadas de un médico.
		\item Modificados los permisos para que un beneficiario pueda tramitar una cita, con y sin volante.
	\end{itemize}

\end{milista}

\subsubsection{Cambios referentes a la conexión con la base de datos} \label{cambiosHibernate}

Sin duda, la capa de persistencia es la parte del servidor front-end que más se ha tenido que modificar para adaptarse a los nuevos requisitos del sistema, puesto que se obligaba a que la persistencia se realizara con \emph{Hibernate} y no a través de un agente SQL (como se comenta en la sección \ref{tecnologias}, aunque sólo se pedía manejar las citas con \emph{Hibernate}, al final se ha usado dicho framework para la persistencia de todo el sistema).

Como se puede ver en el \diagrama{clases}{Gestor Conexiones BBDD}, para poder utilizar \emph{Hibernate} como gestor de persistencia, ha sido necesario cambiar por completo la clase \emph{GestorConexionesBD}, que era la encargada de centralizar todos los acceso a la base de datos. Ahora, los métodos de acceso a la base de datos ya no toman como parámetro una sentencia SQL encapsulada en un \emph{ComandoSQL}, sino que en el caso de las inserciones, actualizaciones y eliminaciones se pasa directamente el objeto persistente, mientras que para realizar las consultas se utiliza una nueva clase llamada \emph{ConsultaHibernate}, que agrupa una sentencia escrita en \emph{HQL} (\emph{Hibernate Query Language}) y sus correspondientes parámetros (igual que se hacía con \emph{ComandoSQL}).

Para adaptarse a estos cambios, se ha tenido que modificar el código de todas las operaciones de las clases de persistencia del servidor front-end (los FPs y la clase \emph{UtilidadesPersistencia}), así como eliminar aquellas clases que gestionaban tablas que no se usaban directamente, sino a través claves ajenas (como sucedía con \emph{FPDireccion}, \emph{FPTipoMedico} y \emph{FPPeriodoTrabajo}). Las nuevas clases de la capa de persistencia se pueden ver en el \diagrama{clases}{Fabricaciones puras}. Conviene destacar que la clase \emph{HibernateSessionFactory} fue generada automáticamente con \emph{MyEclipse} y sólo se tuvo que modificar para que se pudiera elegir la IP y el puerto en el que se encontraba la base de datos.

Además de modificar las clases de la capa de persistencia, para que las clases del dominio fueran compatibles con \emph{Hibernate}, se tuvieron que cambiar todas las relaciones uno-a-muchos para que usaran colecciones de tipo \emph{Set} y no \emph{Vector} como en el servidor del primer cuatrimestre.

Durante el paso de la persistencia a \emph{Hibernate}, surgieron multitud de problemas debido a que los objetos leídos de la base de datos se tenían que enviar a los clientes a través de \emph{RMI}. El framework de \emph{Hibernate} no está diseñado para ser ejecutado en un servidor \emph{RMI}, como lo demuestra el hecho de que sustituya las colecciones de objetos que hay en las clases del dominio por clases especiales que permiten una \emph{lazy load}\footnote{Técnica que consiste en recuperar los objetos de una colección cuando se accede por primera vez a ella.} pero que no son serializables y, por tanto, no se pueden transmitir mediante \emph{RMI}.

Para solucionar estos y otros problemas relacionados con las referencias de los objetos persistentes, se ha tenido que hacer un uso exhaustivo de los métodos \emph{clone} de las clases del dominio, con el fin de convertir las colecciones especiales de \emph{Hibernate} en listas serializables; y añadir nuevos métodos al \emph{GestorConexionesBD}, como \emph{iniciarTransaccion}, \emph{terminarTransaccion} y \emph{borrarCache}, para poder realizar las operaciones más complejas de modificación de usuarios y beneficiarios.

Finalmente, aunque se ha mantenido la estructura de clases que permitiría al servidor front-end funcionar junto con el servidor de respaldo, tras muchas pruebas no se ha conseguido que en ambos servidores se gestione la persistencia a través de \emph{Hibernate} (este framework tampoco está diseñado para ello). Por este motivo, en el nuevo servidor front-end el uso del servidor de respaldo está desactivado por defecto y no se permite activarlo.
